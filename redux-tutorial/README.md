# How to use Redux Toolkit

## Introduction

- In this repo, I will follow the tutorial below, to learn how to use React Redux in my project.

[YouTube Tutorial by Cosden Solutions](https://www.youtube.com/watch?v=5yEG6GhoJBs&ab_channel=CosdenSolutions)

- In the steps below, I will explain and go over my understanding of how to implement `Redux Toolkit`.

## 1. Configure the Store

- In `src/state/store.ts`, create \* configure the store with Redux Toolkit's `configureStore()`

  - **configureStore**: Takes in an object with a single key called `reducer` where we will insert our reducers.

  ```
  // Allows us to configure our store
  import { configureStore } from "@reduxjs/toolkit";

  // The object will take a single 'reducer' key
  export const store = configureStore({
  reducer: {},
  });

  // Using typescript, we need to export 2 types
  // 1. Return type of Root state that allows us to define the type of this selector that allows to access our state variables.
  export type RootState = ReturnType<typeof store.getState>;
  // 2. Allows us to specify the type when using the useDispatch hook
  export type AppDispatch = typeof store.dispatch;
  ```

## 2. Provide the Redux Store to React

- In order, to make the Redux Store available to your react components , you need to use the `Provider` component from `react-redux` @ the top level of the react application `src/main.tsx`

  - Import the Provider from `react-redux` and the `store `from our store.ts
  - Wrap app's root component w/ the `Provider` & pass the Redux `store` to it to allow us to access our state variables in any component

  ```
  import ReactDOM from "react-dom/client";
  import App from "./App.tsx";
  import "./index.css";
  // Allows us to connect our redux store to our react application using the context api.
  import { Provider } from "react-redux";
  // Provide store to the provider to use the store in our application in any component.
  import { store } from "./state/store.ts";

  ReactDOM.createRoot(document.getElementById("root")!).render(
  <Provider store={store}>
  <App />
  </Provider>
  );
  ```

## 3. Setup a Redux State Slice

- In this tutorial, we are creating a counter slice that will represent the counter's value.
  - **Slice**: Define reducers & associated actions together.
  - **Reducers**: Pure functions that take the current state & return a new state by doing an action.

```
   // 0. Import functions from redux toolkit
   import { createSlice, PayloadAction } from "@reduxjs/toolkit";

   // 1. Define our types for our state variables (only for typescript)
   interface CounterState {
   value: number;
   }

   // 2. Create our initial state
   const initialState: CounterState = {
   // Every time the state is initialized, its value will always be set to zero
   value: 0,
   };

   // 3. Create the slice: {name, initialState, reducers, extraReducers}
   const counterSlice = createSlice({
   //
   name: "counter",
   initialState,
   reducers: {
      increment: (state) => {
         state.value += 1;
      },
      decrement: (state) => {
         state.value -= 1;
      },
      incrementByAmount: (state, action: PayloadAction<number>) => {
         state.value += action.payload;
      },
   },
   });

   // 4. Export our Actions.
   export const { increment, decrement, incrementByAmount } = counterSlice.actions;

   // 5. Export Reducer: We can now use the counterSlice reducer in other components.
   export default counterSlice.reducer;
```

### Creating Actions In Reducers

- In our reducer object, we have the following steps to create reducers.

  1. Define them by name (e.g. `increment`)
  2. Pass in a `state` and optionally pass in an `action`
     - `action` only necessary if we need to access its payload
  3. Update the `state` input in the function

  **Key Note**: The `createSlice` function handles creating a copy of the state and replacing the state variable automatically for us.

### Export Actions & Reducers

- **Exporting Actions**: Redux Toolkit automatically generates the action creators for each case reducer defined under the `reducers` key.

- **Exporting Reducer**: The reducer is also automatically generated by redux toolkit. This reducers know how to handle all the actions that have been defined in the slice's recuers' object.
  - Responsible for handling all state changes associated w/ the actions defined in this slice.
  - **Use**: Reducer is included in the Redux store's setup where it is combined w/ other reducers.

## 4. Import Reducer created in Slice in our store.ts

- In our `src/state/store.ts` file, we can now import our `counterReducer` and insert it into our `render` object in the `store`

  ```
  import counterReducer from "./counter/counterSlice";

  // The object will take a single 'reducer' key
  export const store = configureStore({
  reducer: {
     counter: counterReducer,
  },
  });
  ```

- We can have as many slices as we want and would just need to create another file and repeat step 3.
  - Each slice should be responsible for its own state and nothing else.

## 5. Create a Component that uses our Redux State & Actions

- Connect React to Redux by using `useSelector` & `useDispatch`.

- Also import our `RootState` & `AppDispatch` types from the `store.ts` file.

0. Import necessary libraries:

1. Access Redux State using the `useSelector` hook that reads from the state.

   - This hook takes a function that extracts the part of the state the component needs.

2. Initialize our dispatch hook using `useDispatch`.

   - This hook allows us to `send actions` to the `Redux Store`
   - Dispatch takes in as a input an `action` specified from the slice we imported.

3. Create our event handlers that will utilize the `dispatch` hook initialized.

4. In our JSX Component, we will use these event handlers and attach them to elements like buttons.

   ```
   import { useDispatch, useSelector } from "react-redux";
   import { AppDispatch, RootState } from "../state/store";
   import { decrement, increment } from "../state/counter/counterSlice";

   const Counter = () => {
   const count = useSelector((state: RootState) => state.counter.value);
   const dispatch = useDispatch<AppDispatch>();

   const handleIncrement = () => {
      dispatch(increment());
   };

   const handleDecrement = () => {
      dispatch(decrement());
   };

   return (
      <div>
         <h2>{count}</h2>
         <div>
         <button onClick={handleIncrement}>Increment</button>
         <button onClick={handleDecrement}>Decrement</button>
         </div>
      </div>
   );
   };

   export default Counter;
   ```

### Best Practices using Redux in Components

1. **Selecting data with `useSelector`**: Only select the smallest amount of data component needs from store to minimize unnecessary re-renders.

2. **Structuring Redux Actions**: Define actions that represent meaningful events in your app & not just set-state commands.s

3. **Reducers**: Remain pure w/out side effects like API calls and should only compute the next state & return it

4. **Handling Async Logic**: Use middleware like Redux Thunk for side effects like fetching data from an API should be done in thunks & not directly in reducers or components.

5. **Folder Structure**: Files should be related to feature where all (actions, reducers, selectors, and related components) are in their feature folder.

   - Each feature should have its own reducer for larger apps.

## Bonus: Creating Async actions

- Use middleware, `Redux Thunk` to create async functions to allow Redux Store to handle actions that require async operations.

1. In our slice file, import `createAsyncThunk` from redux toolkit.

   ```
   import { createAsyncThunk, createSlice, PayloadAction } from "@reduxjs/toolkit";
   ```

2. **Define our async thunk** by providing a type string a payload creator function.

   - **Payload creator function**: Returns a promise and when the promise resolves, the thunk dispatches the fulfilled action w/ the resolved value as the action payload.
     - If it rejects, the thunk dispatches the rejected action.

   ```
   // createAsyncThunk (name, async function)
   export const incrementByAysnc = createAsyncThunk(
   "counter/incrementAsync",
   async (amount: number) => {
    await new Promise((resolve) => setTimeout(resolve, 1000));
    return amount;
   }
   );
   ```

3. **Handle Thunk Actions in `createSlice`**:

   - We will insert our thunk action in a new key named `extraReducers`.
   - The `builder` parameter will be used create cases to these reducers.
   - `builder.addCase()` will take in 2 parameters.

     1. The Promise's fulfilled attribute of the async function created
     2. A callback function that will update the state's value by the action.payload (the value of the returned promise)

     - This is the same function used in the regular reducer functions.

   - Works in a very similar way w/ slightly different syntax

   ```
   extraReducers: (builder) => {
    builder.addCase(
      incrementByAysnc.fulfilled,
      (state, action: PayloadAction<number>) => {
        state.value += action.payload;
      }
    );
   },
   ```

4. **Chain Cases to the builder**:

   - It would be good practice to use Promise chaining to allow us to handle the entire Thunk.

   ```
     extraReducers: (builder) => {
    builder
      .addCase(incrementByAysnc.pending, (state) => {
        console.log("incrementAysnc.pending");
      })
      .addCase(
        incrementByAysnc.fulfilled,
        (state, action: PayloadAction<number>) => {
          state.value += action.payload;
        }
      )
      .addCase(incrementByAysnc.rejected, (state) => {
        console.log("Error incremented by Async");
      });
   },
   ```

   - Using additional async function in this slide would require creating another `builder` & chaining promises with `.addCase`
